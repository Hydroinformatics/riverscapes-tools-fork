"""
Script meant to run on a custom combined database generated by merge-db-samehuc.py.
This script will generate plots and perform analysis comparing the different FIS runs in the database.

INSTRUCTIONS:
    Run the script from the terminal, passing args (e.g. path to database) as defined

Evan Hackstadt
July 2025
"""

# TODO:
# For each individual FIS run,
#  - visualize the MFs that were changed
#  - view Veg FIS control surface in 3d (see code backbone below)
#  - compare each reach output to standard: % changed; diff averages; 
# Comparing all FIS runs vs. Standard,
#  - generate bar chart of means; add on st.dev. error bars?
#  - generate stacked (categories) bar chart comparing capacity outputs
# INSERT all analysis data into another table in fis-all.db




#imports
import os
import sys
import argparse
import traceback
import sqlite3
import matplotlib.pyplot as plt
import seaborn as sns       # may need to run $ conda install seaborn
import numpy as np
import pandas as pd


def analyze(database, out_dir):
    """
    Master function called by main. Calls sub-functions for different analyses.
    :param database: path to multi-FIS, same-HUC combined BRAT database
    :param out_dir: optional path to a folder to save plots to
    """
    print("Analyzing database {}".format(os.path.basename(database)))
    if out_dir is not None:
        print("Output dir provided; saving plots to {}".format(out_dir))

    # > Call analysis functions. Can turn these on or off

    # capacity_means_box_whisker(database, out_dir)
    # capacity_categories_stacked_bar(database, out_dir)
    # capacity_by_adjustment_pointplot(database, out_dir)
    # capacity_by_adjustment_reg(database, out_dir)


    print("Analysis complete.")


def capacity_means_box_whisker(database, out_dir):
    """
    Generate box and whisker plots of oCC_EX for each FIS run in the database
    :param database: path to multi-huc combined BRAT database (with oCC_EX and WatershedID fields)
    :param out_dir: optional path to a folder to save plots to
    """

    # use raw capacity data (for each reach) from "CombinedOutputs" table
    with sqlite3.connect(database) as conn:
        cur = conn.cursor()

        # figure out what DBs we are working with
        cur.execute("SELECT Label FROM Stats")         # assuming Stats table exists
        all_labels = [row[0] for row in cur.fetchall()]       # convert to list
        oCC_labels = [label for label in all_labels if 'oCC_EX' in label]   # includes ST
        short_labels = [label.replace("oCC_EX_", "") for label in oCC_labels]
        print(f"Found {len(oCC_labels)} sources of oCC_EX data.")

        cur.execute(f"SELECT {', '.join(oCC_labels)} FROM CombinedOutputs")
        results = cur.fetchall()
        data = pd.DataFrame(results, columns=short_labels)
        print(data)
    
    # now construct the plot
    ax = sns.boxplot(data, whis=(0,100))
    ax.set_ylabel("Overall Dam Capacity (dams/km)")
    ax.set_title("Distribution of BRAT Capacity Outputs Across FIS Adjustments")

    if out_dir is not None:
        print(f"...Saving plot to output dir...")
        out_file_path = os.path.join(out_dir, "fis-oCC_EX-box.png")
        plt.savefig(out_file_path)
        plt.close()
    else:
        plt.show()




def capacity_categories_stacked_bar(database, out_dir):        # currently only oCC_EX
    """
    Generate stacked bar charts of oCC_EX for each FIS run in the database
    :param database: path to multi-huc combined BRAT database (with oCC_EX and WatershedID fields)
    :param out_dir: optional path to a folder to save plots to
    """

    # we already have % category values assuming the "Stats" table was made in combined db

    categories = ['None', 'Rare', 'Occasional', 'Frequent', 'Pervasive']
    
    cat_colors = {      # from brat_report.py
        categories[0]: '#f50000',
        categories[1]: '#ffaa00',
        categories[2]: '#f5f500',
        categories[3]: '#4ce601',
        categories[4]: '#005ce6',
    }

    stat_cols = [f"{cat}_Percent" for cat in categories]    # ensure this corresponds to Stats table

    # to store data for stacked bar chart
    x_data = []
    y_data = {cat: [] for cat in categories}    # list is % vals for each huc, in given category

    with sqlite3.connect(database) as conn:
        cur = conn.cursor()

        # figure out what DBs we are working with
        cur.execute("SELECT Label FROM Stats")         # assuming Stats table exists
        all_labels = [row[0] for row in cur.fetchall()]       # convert to list
        oCC_labels = [l for l in all_labels if 'oCC_EX' in l]
        print(f"Found {len(oCC_labels)} sources of oCC_EX data.")

        for label in oCC_labels:
            print(f"Processing {label}...")
            x_data.append(label.replace("oCC_EX_", ""))

            # Select the % values for each category for this HUC
            cur.execute(f"SELECT Label, {', '.join(stat_cols)} FROM Stats WHERE Label LIKE '%{label}%'")
            cap_data = cur.fetchone()[1:]
            print(f"For {label}, selected percents = {cap_data}")
            
            # store data
            for i in range(len(categories)):
                y_data[categories[i]].append(cap_data[i])
    
    # now construct bar chart
    fig, ax = plt.subplots()
    bottom = np.zeros(len(x_data))

    for cat in categories:      # build one layer at a time
        p = ax.bar(x_data, y_data[cat], 0.7, label=cat, color=cat_colors[cat], bottom=bottom)
        bottom += y_data[cat]
        ax.bar_label(p, label_type='center')
    
    ax.set_ylabel("Percent of Watershed in a Category")
    ax.set_title("Existing Capacity Percentages for Different FIS Adjustments")
    ax.legend(loc='upper left', bbox_to_anchor=(1,1))
    plt.tight_layout()
    
    if out_dir is not None:
        print(f"...Saving plot to output dir...")
        out_file_path = os.path.join(out_dir, "fis-oCC_EX-stacked-bar.png")
        plt.savefig(out_file_path)
        plt.close()
    else:
        plt.show()


def capacity_by_adjustment_pointplot(database, out_dir):
    """
    Generate individual point plots of oCC_EX for each type of Adjustment, from the FIS runs in the database
    :param database: path to multi-huc combined BRAT database (with oCC_EX)
    :param out_dir: optional path to a folder to save plots to
    """

    # useful dictionaries
    adj_labels = {   # type of adj: [possible labels]
        "Shift SPlow": ["LEspl", "Standard", "RTspl"],
        "Shift SP2": ["LEsp2", "Standard", "RTsp2"],
        "Shift Slope": ["LEslo", "Standard", "RTslo"],
        "Scale Vegetation FIS": ["CPveg", "Standard", "STveg"],
        "Scale Hydro FIS": ["CPcomb", "Standard", "STcomb"],
        "Scale Both FIS": ["CPboth", "Standard", "STboth"],
        "Shape Vegetation FIS": ["Standard", "CVveg"],
        "Shape Hydro FIS": ["Standard", "CVcomb"],
        "Shape Both FIS": ["Standard", "CVboth"]
    }

    with sqlite3.connect(database) as conn:
        cur = conn.cursor()

        # create a plot for each type of adjustment
        for adj, labels in adj_labels.items():
            cols = ', '.join([f"oCC_EX_{label}" for label in labels])
            cur.execute(f"SELECT {cols} FROM CombinedOutputs")
            results = cur.fetchall()
            adj_data = pd.DataFrame(results, columns=labels)
            print(adj_data)

            sns.pointplot(adj_data, errorbar=None)
            plt.ylabel("Mean Dam Capacity (dams/km)")
            plt.ylim(5, 8)
            plt.title(f"Change in Capacity Output - {adj}")

            if out_dir is not None:
                print(f"...Saving plot to output dir...")
                out_file_path = os.path.join(out_dir, f"fis-{adj.replace(' ', '-')}-pointplot.png")
                plt.savefig(out_file_path)
                plt.close()
            else:
                plt.show()


def capacity_by_adjustment_reg(database, out_dir):
    """
    Generate scatter plots of oCC_EX for each type of Adjustment, from the means of each adjustment in Stats
    :param database: path to multi-huc combined BRAT database (Stats table)
    :param out_dir: optional path to a folder to save plots to
    """

    #                                      -------------- BROKEN --------------
    # TODO: change this so it actually works. will need to change adj_labels to new monte db structure

    # useful dictionaries
    adj_labels = {   # type of adj: [possible labels]
        "Shift SPlow": ["LEspl", "Standard", "RTspl"],
        "Shift SP2": ["LEsp2", "Standard", "RTsp2"],
        "Shift Slope": ["LEslo", "Standard", "RTslo"],
        "Scale Vegetation FIS": ["CPveg", "Standard", "STveg"],
        "Scale Hydro FIS": ["CPcomb", "Standard", "STcomb"],
        "Scale Both FIS": ["CPboth", "Standard", "STboth"],
        "Shape Vegetation FIS": ["Standard", "CVveg"],
        "Shape Hydro FIS": ["Standard", "CVcomb"],
        "Shape Both FIS": ["Standard", "CVboth"]
    }

    with sqlite3.connect(database) as conn:
        cur = conn.cursor()

        # store capacity means
        cur.execute(f"SELECT Label, Mean FROM Stats WHERE Label LIKE '%oCC_EX%'")
        cap_data = cur.fetchall()   # list of (label, mean) tuples
        print(cap_data)

        # create a subplot for each type of adjustment, as well as a master plot for all
        for adj, labels in adj_labels.items():
            adj_data = pd.DataFrame(columns=labels)
            for label in labels:
                adj_data.loc[label] = [row[1] for row in cap_data if label in row[0]]
            print(adj_data)

            # individual plot
            sns.regplot(data=adj_data, ci=None)
            plt.ylim(5, 8)
            plt.ylabel("Mean Dam Capacity (dams/km)")
            plt.title(f"BRAT Outputs under {adj}")
            if out_dir is not None:
                print(f"...Saving plot to output dir...")
                out_file_path = os.path.join(out_dir, f"fis-{adj.replace(' ', '-')}-scatter.png")
                plt.savefig(out_file_path)
                plt.close()
            else:
                plt.show()



def main():

    parser = argparse.ArgumentParser(
        description='Takes a same-HUC, multi-FIS combined BRAT database and performs additional analysis on the output variables.'
    )
    parser.add_argument('database', help='Path to at least one BRAT SQLite database (.gpkg). Add additional paths separated by spaces.', type=str)
    parser.add_argument('-o', '--output', help='(Optional) Path to an output directory where plots will be saved instead of displayed at runtime. If none provided, plots will not be saved.', type=str)
    args = parser.parse_args()
    print(args.database)

    try:
        analyze(args.database, args.output)

    except Exception as ex:
        traceback.print_exc(file=sys.stdout)
        sys.exit(1)

    sys.exit(0)


if __name__ == '__main__':
    main()




''' from scikit-fuzzy docs

#We can simulate at higher resolution with full accuracy
upsampled = np.linspace(-2, 2, 21)
x, y = np.meshgrid(upsampled, upsampled)
z = np.zeros_like(x)

# Loop through the system 21*21 times to collect the control surface
for i in range(21):
    for j in range(21):
        sim.input['error'] = x[i, j]
        sim.input['delta'] = y[i, j]
        sim.compute()
        z[i, j] = sim.output['output']

# Plot the result in pretty 3D with alpha blending
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D # Required for 3D plotting
fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')

surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis',
linewidth=0.4, antialiased=True)

cset = ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)
cset = ax.contourf(x, y, z, zdir='x', offset=3, cmap='viridis', alpha=0.5)
cset = ax.contourf(x, y, z, zdir='y', offset=3, cmap='viridis', alpha=0.5)

ax.view_init(30, 200)

'''