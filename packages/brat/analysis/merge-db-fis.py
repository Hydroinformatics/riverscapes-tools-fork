"""
Merges standard BRAT databases (.gpkg) of DIFFERENT MODELS (e.g. FIS adjustments) on the SAME REGION.
    There will be one copy of each reach in the new db, with a columns of outputs from each source database.
    Thus it is assumed that all rows (reaches) in each source database are parallel and refer to the same reaches.
    # of items in the new db = # of items in any one source db (should be the same)

You can edit the config with your database paths and desired columns and run this script.

Disclaimers:
    Script can only copy integer outputs; geometry columns will not be copied correctly.
    This script was partially generated by AI.

Evan Hackstadt
July 2025
"""

import sqlite3
import os

# --- CONFIGURATION ---

# List your source databases and define shorthand labels for each       # SET THIS
source_dbs = [

]

source_dbs_labels = [   # e.g. ['FIS1', 'FIS2', ... ]                   # SET THIS

]

# Name of the table to extract from in each source database
source_table = 'ReachAttributes'

# Columns to copy (must exist in all source tables)
columns_to_copy_once = [    # ReachIDs should be equal in all source tables
    'ReachID',
    'WatershedID'
]
columns_to_copy_each = [    # model outputs to compare between runs
    'oVC_EX',
    'oCC_EX'
]

# Name of the new database and table
new_db = 'brat-all-fis.db'
new_db_path = ''                        # SET THIS
new_table_name = 'CombinedOutputs'

# Add a column to track the source database?
track_source = True



# --- SCRIPT STARTS HERE ---

# Create the new database and table
new_db_path = os.path.join(new_db_path, new_db)
conn = sqlite3.connect(new_db)
cur = conn.cursor()

# Drop tables if they exists (for repeatable runs)
cur.execute(f"DROP TABLE IF EXISTS {new_table_name}")


# Build CREATE TABLE statement
col_defs = ', '.join([f"{col} REAL" for col in columns_to_copy_once])  # Use REAL for numeric, change as needed
if track_source:
    col_defs += ', SourceDB TEXT'
# Dynamically add output columns for each source db
for col in columns_to_copy_each:
    for label in source_dbs_labels:
        col_defs += f", {col}_{label} REAL"
create_stmt = f"CREATE TABLE {new_table_name} ({col_defs})"
cur.execute(create_stmt)
conn.commit()

# TODO --- update script below!


# For each source database, copy the data
for db in source_dbs:
    print(f"Processing {db}...")
    src_conn = sqlite3.connect(db)
    src_cur = src_conn.cursor()
    col_list = ', '.join(columns_to_copy_each)
    src_cur.execute(f"SELECT {col_list} FROM {source_table}")
    rows = src_cur.fetchall()
    # Prepare insert statement
    placeholders = ', '.join(['?'] * len(columns_to_copy))
    if track_source:
        insert_stmt = f"INSERT INTO {new_table_name} ({col_list}, SourceDB) VALUES ({placeholders}, ?)"
        data = [row + (db,) for row in rows]
    else:
        insert_stmt = f"INSERT INTO {new_table_name} ({col_list}) VALUES ({placeholders})"
        data = rows
    cur.executemany(insert_stmt, data)
    src_conn.close()
    print(f"Inserted {len(rows)} rows from {db}")

conn.commit()
conn.close()
print("Merging complete! Data is in", new_db)