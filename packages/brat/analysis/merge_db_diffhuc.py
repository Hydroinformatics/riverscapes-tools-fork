"""
Merges standard BRAT databases (.gpkg) of the SAME MODEL, on DIFFERENT REGIONS.
    All entries (rows) of each database will be collected ("stacked") together in the new db.
    Assumptions:
        all rows (reaches) in each source database are unique.
        all columns to copy exist in each source database.
    Result:
        # of items in the new db = sum of items in all source dbs

You can edit the config with your database paths and desired columns and run this script.

Disclaimers:
    Script can only copy integer outputs; geometry columns will not be copied correctly.
    This script was partially generated by AI.

Evan Hackstadt
July 2025
"""

# TODO:
# - connect lookup tables to correct features in the new db



import sqlite3

# --- CONFIGURATION ---

# List your source databases
source_dbs = [
    '/Users/evan/Code/OSU-EB3-REU/sqlBRAT/public-runs/Lower-Siletz-River-1710020407/BRAT-LSR-2025/outputs/brat.gpkg',
    '/Users/evan/Code/OSU-EB3-REU/sqlBRAT/public-runs/Middle-Siletz-River-1710020405/BRAT-MSR-2025/outputs/brat.gpkg',
    '/Users/evan/Code/OSU-EB3-REU/sqlBRAT/public-runs/Upper-Siletz-River-1710020404/BRAT-USR-2025/outputs/brat.gpkg',
    '/Users/evan/Code/OSU-EB3-REU/sqlBRAT/public-runs/Rock-Creek-1710020406/BRAT-RC-2025/outputs/brat.gpkg'
]

# Name of the table to extract from in each source database
source_table = 'ReachAttributes'

# Columns to copy (must exist in all source tables)
columns_to_copy = [
    'WatershedID',
    'iGeo_Slope', 
    'iVeg100EX', 'iVeg_30EX',
    'iVeg100HPE', 'iVeg_30HPE',
    'iHyd_Qlow', 'iHyd_Q2',
    'iHyd_SPlow', 'iHyd_SP2',
    'oVC_EX', 'oVC_HPE',
    'oCC_EX', 'oCC_HPE',
    'mCC_EX_CT', 'mCC_HPE_CT',
    'LimitationID', 'RiskID', 'OpportunityID',
    'mCC_HisDep'
    ]  # <-- edit as needed

# Lookup tables to copy (should correspond to the columns above; should be identical in all source databases)
lookup_tables_to_copy = [
    'Watersheds',
    'DamLimitations',
    'DamRisks',
    'DamOpportunities',
    'DamCapacities'
]

# Name of the new database and table
new_db = 'brat-all-siletz-custom.db'
new_table = 'CombinedOutputs'

# Add a column to track the source database?
track_source = True


# --- SCRIPT STARTS HERE ---

# Create the new database and table
conn = sqlite3.connect(new_db)
cur = conn.cursor()

# Drop tables if they exists (for repeatable runs)
cur.execute(f"DROP TABLE IF EXISTS {new_table}")
for table in lookup_tables_to_copy:
    cur.execute(f"DROP TABLE IF EXISTS {table}")

# First copy lookup tables â€” only need to do this from one source database since identical
if lookup_tables_to_copy:
    print("Copying lookup tables...")
    src_conn = sqlite3.connect(source_dbs[0])
    src_cur = src_conn.cursor()
    
    for table in lookup_tables_to_copy:
        print(f"Copying {table}...")
        src_cur.execute(f"SELECT * FROM {table}")
        rows = src_cur.fetchall()
        col_names = [description[0] for description in src_cur.description]
        
        # Create the table in the new database
        col_defs = ', '.join([f"{col} TEXT" for col in col_names])  # Assuming TEXT for simplicity
        create_stmt = f"CREATE TABLE {table} ({col_defs})"
        cur.execute(create_stmt)
        
        # Insert data into the new table
        placeholders = ', '.join(['?'] * len(col_names))
        insert_stmt = f"INSERT INTO {table} ({', '.join(col_names)}) VALUES ({placeholders})"
        cur.executemany(insert_stmt, rows)
        
        print(f"Inserted {len(rows)} rows into {table}")
    
    src_conn.close()


# Build CREATE TABLE statement
col_defs = ', '.join([f"{col} REAL" for col in columns_to_copy])  # Use REAL for numeric, change as needed
if track_source:
    col_defs += ', SourceDB TEXT'
create_stmt = f"CREATE TABLE {new_table} ({col_defs})"
cur.execute(create_stmt)
conn.commit()

# For each source database, copy the data
for db in source_dbs:
    print(f"Processing {db}...")
    src_conn = sqlite3.connect(db)
    src_cur = src_conn.cursor()
    col_list = ', '.join(columns_to_copy)
    src_cur.execute(f"SELECT {col_list} FROM {source_table}")
    rows = src_cur.fetchall()
    # Prepare insert statement
    placeholders = ', '.join(['?'] * len(columns_to_copy))
    if track_source:
        insert_stmt = f"INSERT INTO {new_table} ({col_list}, SourceDB) VALUES ({placeholders}, ?)"
        data = [row + (db,) for row in rows]
    else:
        insert_stmt = f"INSERT INTO {new_table} ({col_list}) VALUES ({placeholders})"
        data = rows
    cur.executemany(insert_stmt, data)
    src_conn.close()
    print(f"Inserted {len(rows)} rows from {db}")

conn.commit()
conn.close()
print("Merging complete! Data is in", new_db)
