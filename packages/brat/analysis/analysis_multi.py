"""
Performs analysis on a custom combined BRAT database generated by merge_db_diffhuc.py
Generates stacked bar chart comparing capacity outputs
Can print or save matplotlib plots.

Evan Hackstadt
July 2025
"""


#imports
import os
import sys
import argparse
import traceback
import sqlite3
import matplotlib.pyplot as plt
import numpy as np


def analyze(database, out_dir):
    """
    Master function called by main. Calls sub-functions for different analyses.
    :param database: path to different-huc combined BRAT database
    :param out_dir: optional path to a folder to save plots to
    """
    print("Analyzing database {}".format(os.path.basename(database)))
    if out_dir is not None:
        print("Output dir provided; saving plots to {}".format(out_dir))

    # > Call analysis functions. Can turn these on or off
    capacity_comparison_bars(database, out_dir)

    print("Analysis complete.")


def capacity_comparison_bars(database, out_dir):
    """
    Generate histograms of iVeg_30EX and iVeg100EX (mean veg suitabilities for each reach)
    :param database: path to different-huc combined BRAT database
    :param out_dir: optional path to a folder to save plots to
    """

    vars = {
        'iVeg_30EX': 'Streamside (30m) vegetation suitability',
        'iVeg100EX': 'Riparian (100m) vegetation suitability'
    }

    # Generate histograms
    for var, descr in vars.items():
        var_data = select_var(database, var)
        plt.hist(var_data, bins=10, edgecolor='black')
        plt.xlabel(var)
        plt.title(f"{descr} Distribution")
        print(f"...Plot for {var} generated...")

        if out_dir is not None:
            print(f"...Saving plot to output dir...")
            out_file_path = os.path.join(out_dir, "suitability-distribution-{}.png".format(var))
            plt.savefig(out_file_path)
            plt.close()
        else:
            plt.show()


def input_distributions(database, out_dir):
    """
    Generate histograms of the distribution of certain input variables
        for reaches with Frequent or Pervasive dams (oCC_EX > 5)
    :param database: path to a BRAT database (.gpkg)
    :param out_dir: optional path to a folder to save plots to
    """
    x_vars = [
        # ('var name', 'description', num_bins, x_scalar)
        # note: set x_scalar to 1.00 if you want the full histogram
        ('iHyd_SPLow', 'Baseflow (watts)', 50, 1.00),
        ('iHyd_SP2', 'Peak Flow (watts)', 50, 0.5),
        ('iGeo_Slope', 'Stream Slope', 50, 1.00),
        ('iGeo_DA', 'Upstream Drainage Area (sq km)', 50, 0.005)
    ]

    capacity_data = select_var(database, 'oCC_EX')

    for var, descr, num_bins, x_scalar in x_vars:
        var_data = select_var(database, var)
        # filter data to high capacity
        pairs = dict(zip(var_data, capacity_data))
        filtered_pairs = {var: cap for var, cap in pairs.items() if cap > 5}

        # plot
        plt.hist(filtered_pairs.keys(), bins=num_bins)
        plt.xlabel(descr)
        plt.ylabel('Count')
        plt.title("Distribution of {} at Frequent/Pervasive reaches".format(var))
        print("...{}-bin histogram for {} generated...".format(num_bins, var))

        if out_dir is not None:
            print(f"...Saving plot to output dir...")
            out_file_path = os.path.join(out_dir, "input-distribution-{}.png".format(var))
            plt.savefig(out_file_path)
            plt.close()
        else:
            plt.show()

        if x_scalar != 1.00:
            # simply remove pairs past the x-cutoff
            cutoff = max(filtered_pairs.keys())*x_scalar
            filtered_pairs = {var: cap for var, cap in filtered_pairs.items() if var < cutoff}
            # plot
            plt.hist(filtered_pairs.keys(), bins=num_bins)
            plt.xlabel(descr)
            plt.ylabel('Count')
            plt.title("[subset] Distribution of {} at Frequent/Pervasive reaches".format(var))
            print("...{}-bin histogram for {} generated...".format(num_bins, var))

            if out_dir is not None:
                print(f"...Saving plot to output dir...")
                out_file_path = os.path.join(out_dir, "input-distribution-{}-zoomed.png".format(var))
                plt.savefig(out_file_path)
                plt.close()
            else:
                plt.show()



    

    


def select_var(database: str, table: str, var: str):
    """
    Utility function to return column of values for a specified feature
    :param database: path to a BRAT database (.gpkg)
    :param var: database name of the feature to be returned"""

    conn = sqlite3.connect(database)
    curs = conn.cursor()
    curs.execute(f'SELECT {var} FROM {table}')
    result = curs.fetchall()
    var_data = [row[0] for row in result]   # convert to list of ints from tuples
    curs.close()

    print("Obtained {} {} values from database...".format(len(var_data), var))
    return var_data



def main():

    parser = argparse.ArgumentParser(
        description='Takes a BRAT databases and performs additional analysis on the output variables in an attempt to identify any patterns.'
    )
    parser.add_argument('database', help='Path to at least one BRAT SQLite database (.gpkg). Add additional paths separated by spaces.', type=str)
    parser.add_argument('-o', '--output', help='(Optional) Path to an output directory where plots will be saved instead of displayed at runtime. If none provided, plots will not be saved.', type=str)
    args = parser.parse_args()
    print(args.database)

    try:
        analyze(args.database, args.output)

    except Exception as ex:
        traceback.print_exc(file=sys.stdout)
        sys.exit(1)

    sys.exit(0)


if __name__ == '__main__':
    main()
