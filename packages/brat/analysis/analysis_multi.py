"""
Performs analysis on a custom combined BRAT database generated by merge_db_diffhuc.py
Generates stacked bar chart comparing capacity outputs
Can print or save matplotlib plots.

Evan Hackstadt
July 2025
"""



# TODO:
#   improper way to display % - just using counts of reaches, but they are different lengths
#   use method in brat_report where we consider the iGeo_Length



#imports
import os
import sys
import argparse
import traceback
import sqlite3
import matplotlib.pyplot as plt
import numpy as np


def analyze(database, out_dir):
    """
    Master function called by main. Calls sub-functions for different analyses.
    :param database: path to different-huc combined BRAT database
    :param out_dir: optional path to a folder to save plots to
    """
    print("Analyzing database {}".format(os.path.basename(database)))
    if out_dir is not None:
        print("Output dir provided; saving plots to {}".format(out_dir))

    # > Call analysis functions. Can turn these on or off
    capacity_comparison_bars(database, out_dir)

    print("Analysis complete.")


def capacity_comparison_bars(database, out_dir):
    """
    Generate stacked bar charts of oCC_EX for each huc in the database
    :param database: path to multi-huc combined BRAT database (with oCC_EX and WatershedID fields)
    :param out_dir: optional path to a folder to save plots to
    """

    # we want to create a stacked bar chart, where each bar is a huc, and the stacks are oCC_EX categories
    # we need to get all reach's oCC_EX data for each huc
    # for each huc, we need to compile the oCC_EX similar to brat report. we want to count how many reaches fall into each category, then summarize as %
    # with the data, we can generate our plot 

    table_name = "ReachAttributes"      # change this if your db's main table has a different name

    custom_huc_names = {        # customize this to your WatershedIDs
        '1710020407': 'Lower Siletz',
        '1710020405': 'Middle Siletz',
        '1710020404': 'Upper Siletz',
        '1710020406': 'Rock Creek',
    }

    categories = ['None', 'Rare', 'Occasional', 'Frequent', 'Pervasive']
    
    cat_colors = {      # from brat_report.py
        categories[0]: '#f50000',
        categories[1]: '#ffaa00',
        categories[2]: '#f5f500',
        categories[3]: '#4ce601',
        categories[4]: '#005ce6',
    }

    oCC_cutoffs = [
        {'label': categories[0], 'upper': 0},
        {'label': categories[1], 'lower': 0, 'upper': 1},
        {'label': categories[2], 'lower': 1, 'upper': 5},
        {'label': categories[3], 'lower': 5, 'upper': 15},
        {'label': categories[4], 'lower': 15}
    ]

    # to store data for stacked bar chart
    x_data = []
    y_data = {cat: [] for cat in categories}    # list is % vals for each huc, in given category

    with sqlite3.connect(database) as conn:
        cur = conn.cursor()

        # figure out what hucs we are working with
        cur.execute(f"SELECT DISTINCT WatershedID FROM {table_name}")
        hucs = [row[0] for row in cur.fetchall()]   # convert to list of ints
        print(f"Found {len(hucs)} distinct HUCs in db.")

        for huc in hucs:
            print(f"Processing HUC {huc}...")
            # append huc or custom name to x array for bar chart
            if huc in custom_huc_names.keys():
                x_data.append(custom_huc_names[huc])
            else:
                x_data.append(huc)

            cur.execute(f"SELECT oCC_EX, WatershedID FROM {table_name} WHERE WatershedID = {huc};")
            cap_data = [val[0] for val in cur.fetchall()]   # only store oCC_EX
            huc_total = len(cap_data)
            print(f"Selected {huc_total} reaches corresponding to HUC {huc}")

            for cat in oCC_cutoffs:
                label = cat['label']
                lower = cat['lower'] if 'lower' in cat.keys() else None
                upper = cat['upper'] if 'upper' in cat.keys() else None
                
                # Filter to values within this category
                if lower is not None and upper is not None:
                    filtered = [val for val in cap_data if lower < val <= upper]
                elif lower is not None:
                    filtered = [val for val in cap_data if val > lower]
                elif upper is not None:
                    filtered = [val for val in cap_data if val <= upper]
                else:
                    filtered = cap_data  # fallback, should not happen

                percent = round((100 * len(filtered) / huc_total), 1)
                y_data[label].append(percent)
    
    # now construct bar chart
    fig, ax = plt.subplots()
    bottom = np.zeros(len(x_data))

    for cat in categories:      # build one layer at a time
        p = ax.bar(x_data, y_data[cat], 0.7, label=cat, color=cat_colors[cat], bottom=bottom)
        bottom += y_data[cat]
        ax.bar_label(p, label_type='center')
    
    ax.set_title("Percent breakdown of Existing Capacity across HUCs")
    ax.legend()
    
    if out_dir is not None:
        print(f"...Saving plot to output dir...")
        out_file_path = os.path.join(out_dir, "oCC_EX-stacked-bar.png")
        plt.savefig(out_file_path)
        plt.close()
    else:
        plt.show()



def main():

    parser = argparse.ArgumentParser(
        description='Takes a BRAT databases and performs additional analysis on the output variables in an attempt to identify any patterns.'
    )
    parser.add_argument('database', help='Path to at least one BRAT SQLite database (.gpkg). Add additional paths separated by spaces.', type=str)
    parser.add_argument('-o', '--output', help='(Optional) Path to an output directory where plots will be saved instead of displayed at runtime. If none provided, plots will not be saved.', type=str)
    args = parser.parse_args()
    print(args.database)

    try:
        analyze(args.database, args.output)

    except Exception as ex:
        traceback.print_exc(file=sys.stdout)
        sys.exit(1)

    sys.exit(0)


if __name__ == '__main__':
    main()
