"""
Performs analysis on a custom combined BRAT database generated by merge_db_diffhuc.py
Generates stacked bar chart comparing capacity outputs
Can print or save matplotlib plots.

Evan Hackstadt
July 2025
"""


#imports
import os
import sys
import argparse
import traceback
import sqlite3
import matplotlib.pyplot as plt
import numpy as np


def analyze(database, out_dir):
    """
    Master function called by main. Calls sub-functions for different analyses.
    :param database: path to different-huc combined BRAT database
    :param out_dir: optional path to a folder to save plots to
    """
    print("Analyzing database {}".format(os.path.basename(database)))
    if out_dir is not None:
        print("Output dir provided; saving plots to {}".format(out_dir))

    # > Call analysis functions. Can turn these on or off
    capacity_comparison_bars(database, out_dir)

    print("Analysis complete.")


def capacity_comparison_bars(database, out_dir):
    """
    Generate stacked bar charts of oCC_EX for each huc in the database
    :param database: path to multi-huc combined BRAT database (with oCC_EX and WatershedID fields)
    :param out_dir: optional path to a folder to save plots to
    """

    # we want to create a stacked bar chart, where each bar is a huc, and the stacks are oCC_EX categories
    # we need to get all reach's oCC_EX data for each huc
    # for each huc, we need to compile the oCC_EX similar to brat report. we want to count how many reaches fall into each category, then summarize as %
    # with the data, we can generate our plot 

    table_name = "CombinedOutputs"      # change this if your db's main table has a different name

    custom_huc_names = {        # customize this to your WatershedIDs
        '1710020407': 'Lower Siletz',
        '1710020405': 'Middle Siletz',
        '1710020404': 'Upper Siletz',
        '1710020406': 'Rock Creek',
    }

    categories = ['None', 'Rare', 'Occasional', 'Frequent', 'Pervasive']

    oCC_cutoffs = [
        {'label': categories[0], 'upper': 0},
        {'label': categories[1], 'lower': 0, 'upper': 1},
        {'label': categories[2], 'lower': 1, 'upper': 5},
        {'label': categories[3], 'lower': 5, 'upper': 15},
        {'label': categories[4], 'lower': 15}
    ]

    # to store data for stacked bar chart
    x_data = []
    y_data = {cat: [] for cat in categories}    # list is % vals for each huc, in given category

    with sqlite3.connect(database) as conn:
        cur = conn.cursor()

        # figure out what hucs we are working with
        cur.execute(f"SELECT DISTINCT WatershedID FROM {table_name}")
        hucs = cur.fetchall()
        print(f"Found {len(hucs)} distinct HUCs in db.")

        for huc in hucs:
            print(f"Processing HUC {huc}...")
            # append huc or custom name to x array for bar chart
            x_data.append(custom_huc_names[huc] if custom_huc_names[huc] else huc)

            cur.execute(f"SELECT oCC_EX FROM {table_name} WHERE WatershedID = {huc}")
            huc_data = cur.fetchall()
            huc_total = len(huc_data)
            print(f"Selected {huc_total} reaches corresponding to HUC {huc}")

            for cat in oCC_cutoffs:
                lower = cat['lower'] if cat['lower'] else None
                upper = cat['upper'] if cat['upper'] else None
                filtered = huc_data
                if lower:
                    filtered = [val for val in filtered if val > lower]
                if upper:
                    filtered = [val for val in filtered if val <= upper]
                
                percent = round((len(filtered) / huc_total), 1)
                y_data[cat].append(percent)
    
    # now construct bar chart
    fig, ax = plt.subplots()
    bottom = np.zeros(len(x_data))

    for cat in categories:      # build one layer at a time
        ax.bar(x_data, y_data[cat], label=cat, bottom=bottom)
        bottom += y_data[cat]
    
    if out_dir is not None:
        print(f"...Saving plot to output dir...")
        out_file_path = os.path.join(out_dir, "oCC_EX-stacked-bar.png")
        plt.savefig(out_file_path)
        plt.close()
    else:
        plt.show()



def main():

    parser = argparse.ArgumentParser(
        description='Takes a BRAT databases and performs additional analysis on the output variables in an attempt to identify any patterns.'
    )
    parser.add_argument('database', help='Path to at least one BRAT SQLite database (.gpkg). Add additional paths separated by spaces.', type=str)
    parser.add_argument('-o', '--output', help='(Optional) Path to an output directory where plots will be saved instead of displayed at runtime. If none provided, plots will not be saved.', type=str)
    args = parser.parse_args()
    print(args.database)

    try:
        analyze(args.database, args.output)

    except Exception as ex:
        traceback.print_exc(file=sys.stdout)
        sys.exit(1)

    sys.exit(0)


if __name__ == '__main__':
    main()
